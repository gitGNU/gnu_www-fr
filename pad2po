#!/bin/bash

# NAME
#    pad2po - PAD to PO converter

# SYNOPSIS
#    pad2po [/path/to/NAME.txt]

# DESCRIPTION
#    This script converts a translated pad, created with html-to-pad or
#    pot-to-pad (with link extraction), into a gnu.org PO file and fills out
#    the PO header with generic data (charset, encoding, language, team
#    address). It can be launched from the application and contextual menus of
#    GNOME or KDE.

# REQUIREMENTS
#    * The pad must have been created by pot2pad, or html2pad from
#      pad-convert-0.21+.
#    * The working directory (wdir) is $HOME/pad. This can  be  changed  by
#      modifying one line in the script.
#    * NAME.pot must be at the proper place in the www directory.
#    * No  blank line between an original paragraph and its translation, or
#      between the string or link label and  the original. But the translation
#      may be blank.
#    * No spurious LFs!

# OPTIONS
#    None yet.

# OUTPUT, WARNINGS and ERRORS
#    NAME.fr.po and possibly NAME.warn are created in the working directory.
#    The exit code is 1 if the input file does not have the .txt extension
#    or is empty, 2 if there are warnings, 0 otherwise.

# HOW-TO
#    1. Export the translated pad as plain text.
#    2. Launch the script as explained in pot2pad.
#    3. Add the translator's notes by hand, if any.
#       TODO: try to insert them automatically.
#    4. Finish up in the PO editor.

# Copyright (C) 2013 Whoever.
# You may redistribute this script and/or modify it under the terms of the
# Creative Commons CC0 license
# (http://creativecommons.org/publicdomain/zero/1.0/legalcode).

wdir=$HOME/pad

set -e
mkdir -p $wdir

if [ -f /usr/bin/kwrite ]; then
  editor=kwrite
elif [ -f /usr/bin/gedit ]; then
  editor=gedit
else
  editor=vi
fi

echo -e "\n## pad2po : Conversion d'un pad en fichier PO ##\n"

## File input

  # 1. via the Nautilus script (new_txt is already set),

  # 2. via the application launcher of the contextual menu or the command line,
input=$1
if [ -z "$new_txt" ]; then
  new_txt=$input
fi
if [ -n "$new_txt" ]; then
  echo "*** Fichier TXT à convertir : $new_txt"
else

  # 3. via the application menu (drag-and-drop the file or enter it directly).
  echo "*** Quel est le fichier TXT à convertir ?"
  read new_txt
fi

# Clean up the input to get the full path, and extract the name of the
# document.
path=${new_txt//\'/}
file=${path##*/}
name1=${file%.txt}
name=${name1#FrEn-}

# Check for non-zero content and txt extension.
if [ -n "$path" -a "$name" != "$file" ]; then
  exit_code=0

  # Create temporary files.
  TMP1=$(mktemp -t pad2po.XXXXXX) || exit 1 # Pad
  TMP2=$(mktemp -t pad2po.XXXXXX) || exit 1 # Translated strings / header
  TMP3=$(mktemp -t pad2po.XXXXXX) || exit 1 # POT content -> PO content
  TMP4=$(mktemp -t pad2po.XXXXXX) || exit 1 # Pad content / processed tr. strings
  TMP5=$(mktemp -t pad2po.XXXXXX) || exit 1 # Links
  trap 'rm -f "$TMP1" "$TMP2" "$TMP3" "$TMP4" "$TMP5"' EXIT

## Link insertion

  # Make a working copy of the translated pad.
  cp $path $TMP1

  # Put the links aside.
  sed -n '/<lnk no./,$ p' $TMP1 > $TMP5

  # If indeed there are links,
  if [ -s $TMP5 ]; then
    # Escape the & which are found in some links.
    sed -i 's,&,\\&,g' $TMP5
    # Remove the string number (if created by html2pad).
    sed -i 's,^#[0-9]\+~,,' $TMP5
    # remove the original strings,
    sed -i -e '/<lnk no./ {N;N; s,^\(<lnk no.[0-9]\+>\)\n.*\n\(.\+\)$,\1\2,}' \
           -e '/<lnk no./ {N; s,^\(<lnk no.[0-9]\+>\)\n\(.\+$\),\1\2,}' $TMP5

    # and insert the translated links (if any) where they belong.
    i=1
    while link=$(grep "<lnk no.$i>" $TMP5) ; do
      sed -i "s|href={$i}|href=\"$link\"|" $TMP1
      i=$(( i + 1 ))
    done
    # Remove the link numbers and the list of links from the text.
    sed -i -e '/^<lnk no./,$ d' \
           -e 's,<lnk no\.[0-9]\+>,,g' $TMP1
    # Remove the link numbers and the list of links from the text.
    sed -i -e '/^<lnk no./,$ d' \
           -e 's,<lnk no\.[0-9]\+>,,g' $TMP1
  fi

## String replacement

  # Remove the pot header and footer.
  sed '1,/"Content-Transfer-Encoding:/d' $wdir/$name.pot > $TMP3
  sed -i '/^#. TRANSLATORS: Use space (SPC)/,$d' $TMP3
  # Make sure all the « msgstr "" » in the pot are empty.
  sed -i '/^msgstr ""$/ {N; s,^msgstr ""\n",msgstr ",}' $TMP3

  # Select the pad contents. The pad may have been created by pot2pad (the
  # string label starts with "#.") or html2pad (the label starts with
  # "#[0-9]").
  grep -A2 "^#\(\.\|[0-9]\)" $TMP1 > $TMP2  || true
  # Print the translated strings: one line out of 4, starting at line 3.
  # Why 4? That's because grep -A2 adds a separator line.
  sed -n '3~4'p $TMP2 > $TMP4

  if grep "[[:print:]]" $TMP4 > /dev/null ; then

    # Initialize warnings.
    exit_code=0
    rm -f $wdir/$name.warn

    # Escape the "&".
    sed -i 's,&,\\\\&,' $TMP4

    # Start a counter for the strings.
    n=0

    # Replace pot msgstr's with pad msgstr's.
    while read translation; do
      let n=n+1
      sed_exit_code=0

      if [ -z "$translation" ]; then
        echo "La chaîne $n n'a pas été traduite." >> $wdir/$name.warn \
        && exit_code=2
      fi

      # Check for possible fuzzy strings (containing *...* or |).
      if [[ "$translation" = *§*§* ]]; then
         echo "Il reste probablement une incertitude
    délimitée par \"§\" dans la chaîne $n." >> $wdir/$name.warn \
      && exit_code=2
      fi
      if [[ "$translation" =~ '|' ]]; then
        echo "Il reste un choix à faire dans la chaîne $n
    (options séparées par \"|\")." >> $wdir/$name.warn && exit_code=2
      fi

      # Replace pot msgstr's with translated strings, identified by a number.
      sed -i "0, /^msgstr \"\"/ s||$n $translation|" $TMP3 \
      2>/dev/null || sed_exit_code=$?

      # Sed gives an error when it sees a vertical bar in the text. In this
      # case, replace with the string number only.
      if (( "$sed_exit_code" == 1 )); then
        sed -i "0, /^msgstr \"\"/ s||$n |" $TMP3
        echo "La chaîne $n n'a pas pu être insérée." >> $wdir/$name.warn \
        && exit_code=2
      fi
    done < $TMP4

    # Replace the numbers with "msgstr", escape the internal double quotes in
    # msgstr's and add double-quote delimiters.
    sed -i -e 's,^[0-9]\+ ,msgstr ,' \
           -e '/^msgstr/ s,",\\",g' \
           -e 's,^msgstr \(.*\)$,msgstr "\1",' $TMP3
    # Isolate the pot header.
    sed '/^#. type: Content of:/,$d' $wdir/$name.pot |
    sed '$d' > $TMP2
    # Fill it out with generic data.
    sed -i -e 's,charset=CHARSET,charset=utf-8,' \
           -e 's,Encoding: ENCODING,Encoding: 8bit,' \
           -e 's,LANGUAGE <LL@li.org>,French <trad-gnu@april.org>,' \
           -e 's,^# LANGUAGE translation,# French translation,' \
           -e "s,# Copyright (C) YEAR,# Copyright (C) $(date +'%Y')," \
           -e '/^# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.$/d' \
           -e '/^"Language-Team:/ a"Language: fr\\n"' $TMP2
    # Isolate the pot footer
    sed '1,/#. TRANSLATORS: Use space (SPC)/d' $wdir/$name.pot > $TMP4

    # Add the header and footer to the new po.
    cat $TMP2 $TMP3 $TMP4 > $wdir/$name.fr.po

    # Display the warning messages and the translated page.
    $editor $wdir/$name.fr.po $wdir/$name.warn

  else
    echo "*** Le pad ne semble pas avoir été traduit du tout."
    echo "    Valider pour fermer le terminal."
    read
    exit 2
  fi

else
  echo "*** Ce n'est pas un fichier TXT, ou bien il est vide."
  echo "    Valider pour fermer le terminal."
  read
  exit 1
fi

exit $exit_code
